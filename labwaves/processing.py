"""Collection of pure functions that take a PIL Image object as
input.  No necessary context, no side effects except the creation of
a temporary image file in barrel_correction.

Functions:

- barrel_correct: correct barrel distortion in an image with given coefficients

- perspective_transform: perspective transform an image with given
                         coefficients

- perspective_coefficients: Helper function. Calculate the perspective
                            projection matrix that would transform a given set
                            of four points to another given set of four points.

- crop: crop an image to a supplied box

- draw_text: put a banner of specified text at the top and bottom of
             the image.
"""

from __future__ import division

# necessary IO modules for using external functions
import subprocess
from cStringIO import StringIO

import numpy as np
from PIL import Image
from PIL import ImageDraw


### PURE FUNCTIONS ###
# operate on a single image object
def barrel_correct(im, coeffs):
    """Uses Imagemagick convert to apply a barrel correction to
    an image.

    Inputs: im - a PIL Image object
            coeffs - a list of four coefficients [a, b, c, d] which
                     can be str, float or int, will be converted to
                     str anyway.

    Outputs: A corrected PIL Image object.

    Barrel distortion is radial. For a given output pixel a
    distance r_dest from the centre of the image, the corresponding
    source pixel is found at a radius r_src using a set of four
    coefficients:

    a, b, c, d = coeffs
    r_src = r_dest * (a * r_dest ** 3 + b * r_dest ** 2 + c * r_dest + d)

    This function is a bit annoying as it calls an external function
    to do the work, which means doing IO in a supposedly pure
    function.

    The solution is to do the IO using strings in memory.

    Consistency of these low level functions is more important
    than performance as we can solve the latter by using a bigger
    computer.
    """
    # check image is RGB
    if im.mode == 'RGBA':
        im = im.convert('RGB')

    # save image to string buffer
    buff = StringIO()
    # using im.format as the buffer format is fastest, but
    # there are issues with jpeg quantisation tables...
    # look at the test for this.
    tmp_format = 'TIFF'
    im.save(buff, format=tmp_format)
    imstd = buff.getvalue()

    # format coefficients for convert
    scoeffs = ' '.join([str(c) for c in coeffs])

    cmd = ["convert",
           "-distort", "Barrel",
           scoeffs,
           '-',
           '-']
    proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    stdoutdata, stderrdata = proc.communicate(input=imstd)

    out_im = Image.open(StringIO(stdoutdata))

    # TODO: force the output of barrel_correct to be of type jpg
    return out_im


def perspective_transform(im, coeffs):
    """Apply a perspective transform to an image.

    Inputs: im - a PIL image object

            coeffs - a sequence of perspective coefficients
                     (a, b, c, d, e, f, g, h) that correspond
                     to the transform matrix

    Output: a transformed image object

    The coefficients can be generated by another method,
    perspective_coefficients.
    """
    args = {'size':     im.size,
            'method':   Image.PERSPECTIVE,
            'data':     coeffs,
            'resample': Image.BILINEAR}
    trans = im.transform(**args)
    return trans


def perspective_coefficients(X, x):
    """Calculates the perspective coefficients that would affect
    a four point perspective transform on a given list of
    four input points, x, and output X.

    Inputs:
        X - (X1, Y1), (X2, Y2), (X3, Y3), (X4, Y4)
            output points
        x - (x1, y1), (x2, y2), (x3, y3), (x4, y4)
            input points

    Returns:
        Vector of perspective transform coefficients,
        (a, b, c, d, e, f, g, h)

    N.B. This calculates the coefficients needed to obtain the
    corresponding INPUT to a given OUTPUT, which is what we need
    for PIL transform.

    Solves the equation Ac = X.

    See [1] and [2] for more.

    [1]: http://xenia.media.mit.edu/~cwren/interpolator/
    [2]: http://www.robots.ox.ac.uk/~vgg/presentations/bmvc97/criminispaper/
    """
    (x1, y1), (x2, y2), (x3, y3), (x4, y4) = x
    (X1, Y1), (X2, Y2), (X3, Y3), (X4, Y4) = X

    A = np.matrix([[x1, y1, 1,  0,  0, 0, -X1 * x1, -X1 * y1],
                   [0,   0, 0, x1, y1, 1, -Y1 * x1, -Y1 * y1],
                   [x2, y2, 1,  0,  0, 0, -X2 * x2, -X2 * y2],
                   [0,   0, 0, x2, y2, 1, -Y2 * x2, -Y2 * y2],
                   [x3, y3, 1,  0,  0, 0, -X3 * x3, -X3 * y3],
                   [0,   0, 0, x3, y3, 1, -Y3 * x3, -Y3 * y3],
                   [x4, y4, 1,  0,  0, 0, -X4 * x4, -X4 * y4],
                   [0,   0, 0, x4, y4, 1, -Y4 * x4, -Y4 * y4]])

    c = np.linalg.solve(A, np.asarray(X).flatten())

    return c


def crop(im, box):
    """Crop an image such that it is physically orientated.

    Inputs: im - an image object
            box - tuple, defining the (left, upper, right, lower) pixel

    Output: a cropped image object
    """
    cropped = im.crop(box)
    return cropped


def draw_text(im, upper_text, lower_text, upper_bar, lower_bar, font, text_colour, bg_colour):
    """Make an upper and lower banner of text on an image.

    Inputs: im - PIL image object
            upper_text - string, the text for the upper banner
            lower_text - string, the text for the lower banner
            upper_bar - int, the height of the upper banner (pixels)
            lower_bar - int, the height of the lower banner (pixels)
            font - ImageFont.font instance to use
            text_colour - colour of the text, e.g. 'white'
            bg_colour - colour of the background, e.g. 'black'

    Outputs: an image object
    """
    w, h = im.size
    # position of the text
    upper_text_pos = (0, 0)
    lower_text_pos = (0, h - lower_bar)
    # box of the background
    upper_background_box = (0, 0, w, upper_bar)
    lower_background_box = (0, h - lower_bar, w, h)

    # draw has side effects so work on copy
    dim = im.copy()
    draw = ImageDraw.Draw(dim)
    draw.rectangle(upper_background_box, fill=bg_colour)
    draw.rectangle(lower_background_box, fill=bg_colour)
    draw.text(upper_text_pos, upper_text, font=font, fill=text_colour)
    draw.text(lower_text_pos, lower_text, font=font, fill=text_colour)

    return dim

### /PURE FUNCTIONS ###
